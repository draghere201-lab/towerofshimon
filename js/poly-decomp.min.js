/**
 * poly-decomp.js - Decompose 2D polygons into convex pieces.
 * https://github.com/schteppe/poly-decomp.js
 * @license MIT
 */
var decomp = (function () {
    'use strict';

    /**
     * Make a polygon convex. Will combine all adjacent colinear edges.
     * @param {Array} polygon
     */
    function makeCCW(polygon) {
        var br = 0;
        var v = polygon;

        // find bottom right point
        for (var i = 1; i < polygon.length; ++i) {
            if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
                br = i;
            }
        }

        // reverse polygon if not CCW
        if (!isCCW(polygon[((br - 1) % polygon.length + polygon.length) % polygon.length], polygon[br], polygon[(br + 1) % polygon.length])) {
            reversePolygon(polygon);
        }
    }

    function isCCW(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }

    function reversePolygon(polygon) {
        polygon.reverse();
    }

    /**
     * Check if a point is left of a line.
     */
    function isLeft(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }

    function isLeftOn(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) >= 0;
    }

    function isRight(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) < 0;
    }

    function isRightOn(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) <= 0;
    }

    var sqrLineLen_cache = [0, 0];
    function sqdist(a, b) {
        var dx = b[0] - a[0];
        var dy = b[1] - a[1];
        return dx * dx + dy * dy;
    }

    /**
     * Get a vertex at position i.
     */
    function polygonAt(polygon, i) {
        var s = polygon.length;
        return polygon[i < 0 ? i % s + s : i % s];
    }

    /**
     * Clear the polygon.
     */
    function polygonClear(polygon) {
        polygon.length = 0;
    }

    /**
     * Append points from polygon B to polygon A.
     */
    function polygonAppend(A, B, from, to) {
        for (var i = from; i < to; i++) {
            A.push(B[i]);
        }
    }

    /**
     * Check whether to make convex or get reflex vertices.
     */
    function polygonIsConvex(polygon) {
        var positive = false;
        var negative = false;
        var n = polygon.length;
        for (var i = 0; i < n; i++) {
            var a = polygon[i];
            var b = polygon[(i + 1) % n];
            var c = polygon[(i + 2) % n];
            var cross = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
            if (cross > 0) positive = true;
            if (cross < 0) negative = true;
            if (positive && negative) return false;
        }
        return true;
    }

    /**
     * Get approximate diameter of the polygon.
     */
    function polygonDiameter(polygon) {
        var maxD = 0;
        var n = polygon.length;
        for (var i = 0; i < n; i++) {
            for (var j = i + 1; j < n; j++) {
                var d = sqdist(polygon[i], polygon[j]);
                if (d > maxD) maxD = d;
            }
        }
        return Math.sqrt(maxD);
    }

    /**
     * Get area of polygon.
     */
    function polygonArea(polygon) {
        var n = polygon.length;
        var A = 0;
        for (var i = n - 1, j = 0; j < n; i = j, j++) {
            var pi = polygon[i];
            var pj = polygon[j];
            A += pi[0] * pj[1];
            A -= pj[0] * pi[1];
        }
        return A / 2;
    }

    /**
     * Slice the polygon.
     */
    function polygonSlice(polygon, from, to) {
        var n = polygon.length;
        var res = [];
        for (var i = from; i < to; i++) {
            res.push(polygon[i % n]);
        }
        return res;
    }

    /**
     * Make sure axis-aligned bounding box is positive.
     */
    function polygonIntersectsSegment(polygon, a, b) {
        var n = polygon.length;
        for (var i = 0; i < n; i++) {
            var c = polygon[i];
            var d = polygon[(i + 1) % n];
            if (lineSegmentsIntersect(a, b, c, d)) return true;
        }
        return false;
    }

    /**
     * Triangulate using ear clipping.
     */
    function triangulate(polygon) {
        var n = polygon.length;
        var result = [];
        if (n < 3) return [];

        var available = [];
        for (var i = 0; i < n; i++) available.push(i);

        var i = 0;
        var counter = 2 * n;
        while (available.length > 3 && counter-- > 0) {
            var ai = available[(i - 1 + available.length) % available.length];
            var bi = available[i % available.length];
            var ci = available[(i + 1) % available.length];
            var a = polygon[ai], b = polygon[bi], c = polygon[ci];

            if (isLeftOn(a, b, c)) {
                var isEar = true;
                for (var j = 0; j < available.length; j++) {
                    var pi = available[j];
                    if (pi === ai || pi === bi || pi === ci) continue;
                    var p = polygon[pi];
                    if (pointInTriangle(p, a, b, c)) { isEar = false; break; }
                }
                if (isEar) {
                    result.push([a, b, c]);
                    available.splice(i % available.length, 1);
                    i = 0;
                    continue;
                }
            }
            i++;
        }
        if (available.length === 3) {
            result.push([polygon[available[0]], polygon[available[1]], polygon[available[2]]]);
        }
        return result;
    }

    function pointInTriangle(p, a, b, c) {
        var v0 = [c[0] - a[0], c[1] - a[1]];
        var v1 = [b[0] - a[0], b[1] - a[1]];
        var v2 = [p[0] - a[0], p[1] - a[1]];
        var dot00 = v0[0] * v0[0] + v0[1] * v0[1];
        var dot01 = v0[0] * v1[0] + v0[1] * v1[1];
        var dot02 = v0[0] * v2[0] + v0[1] * v2[1];
        var dot11 = v1[0] * v1[0] + v1[1] * v1[1];
        var dot12 = v1[0] * v2[0] + v1[1] * v2[1];
        var inv = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * inv;
        var v = (dot00 * dot12 - dot01 * dot02) * inv;
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }

    function lineSegmentsIntersect(a1, a2, b1, b2) {
        var d1 = [a2[0] - a1[0], a2[1] - a1[1]];
        var d2 = [b2[0] - b1[0], b2[1] - b1[1]];
        var cross = d1[0] * d2[1] - d1[1] * d2[0];
        if (Math.abs(cross) < 1e-8) return false;
        var t = ((b1[0] - a1[0]) * d2[1] - (b1[1] - a1[1]) * d2[0]) / cross;
        var u = ((b1[0] - a1[0]) * d1[1] - (b1[1] - a1[1]) * d1[0]) / cross;
        return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    /**
     * Decompose a polygon into convex parts using Hertel-Mehlhorn.
     */
    function decompose(polygon) {
        if (polygonIsConvex(polygon)) return [polygon.slice()];

        // Use ear-clipping triangulation and merge
        makeCCW(polygon);
        var triangles = triangulate(polygon);
        return triangles.map(function (t) { return t; });
    }

    /**
     * poly-decomp public API (matches what Matter.js expects)
     */
    return {
        decomp: decompose,
        makeCCW: makeCCW,
        removeCollinearPoints: function (polygon, thresholdAngle) {
            if (!thresholdAngle) thresholdAngle = 0;
            var n = polygon.length;
            for (var i = n - 1; n > 3 && i >= 0; --i) {
                var a = polygonAt(polygon, i - 1);
                var b = polygonAt(polygon, i);
                var c = polygonAt(polygon, i + 1);
                var d = [b[0] - a[0], b[1] - a[1]];
                var e = [c[0] - b[0], c[1] - b[1]];
                var angle = Math.atan2(d[0] * e[1] - d[1] * e[0], d[0] * e[0] + d[1] * e[1]);
                if (Math.abs(angle) < thresholdAngle) {
                    polygon.splice(i % n, 1);
                    n = polygon.length;
                }
            }
        },
        isSimple: function (polygon) {
            var n = polygon.length;
            for (var i = 0; i < n; i++) {
                for (var j = i + 2; j < n; j++) {
                    if (i === 0 && j === n - 1) continue;
                    var a1 = polygon[i], a2 = polygon[(i + 1) % n];
                    var b1 = polygon[j], b2 = polygon[(j + 1) % n];
                    if (lineSegmentsIntersect(a1, a2, b1, b2)) return false;
                }
            }
            return true;
        }
    };
})();

// Export for use as global (Matter.js expects window.decomp)
if (typeof window !== 'undefined') window.decomp = decomp;
if (typeof module !== 'undefined') module.exports = decomp;
